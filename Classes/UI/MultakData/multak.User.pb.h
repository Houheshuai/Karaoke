// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: multak.User.proto

#ifndef PROTOBUF_multak_2eUser_2eproto__INCLUDED
#define PROTOBUF_multak_2eUser_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2004001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
// @@protoc_insertion_point(includes)

namespace multak {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_multak_2eUser_2eproto();
void protobuf_AssignDesc_multak_2eUser_2eproto();
void protobuf_ShutdownFile_multak_2eUser_2eproto();

class User;

enum User_Status {
  User_Status_UnknownS = 0,
  User_Status_Online = 1,
  User_Status_Offline = 2
};
bool User_Status_IsValid(int value);
const User_Status User_Status_Status_MIN = User_Status_UnknownS;
const User_Status User_Status_Status_MAX = User_Status_Offline;
const int User_Status_Status_ARRAYSIZE = User_Status_Status_MAX + 1;

enum User_Available {
  User_Available_UnknownA = 0,
  User_Available_Open = 1,
  User_Available_Locked = 2,
  User_Available_Delete = 3
};
bool User_Available_IsValid(int value);
const User_Available User_Available_Available_MIN = User_Available_UnknownA;
const User_Available User_Available_Available_MAX = User_Available_Delete;
const int User_Available_Available_ARRAYSIZE = User_Available_Available_MAX + 1;

// ===================================================================

class User : public ::google::protobuf::MessageLite {
 public:
  User();
  virtual ~User();
  
  User(const User& from);
  
  inline User& operator=(const User& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const User& default_instance();
  
  void Swap(User* other);
  
  // implements Message ----------------------------------------------
  
  User* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const User& from);
  void MergeFrom(const User& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  typedef User_Status Status;
  static const Status UnknownS = User_Status_UnknownS;
  static const Status Online = User_Status_Online;
  static const Status Offline = User_Status_Offline;
  static inline bool Status_IsValid(int value) {
    return User_Status_IsValid(value);
  }
  static const Status Status_MIN =
    User_Status_Status_MIN;
  static const Status Status_MAX =
    User_Status_Status_MAX;
  static const int Status_ARRAYSIZE =
    User_Status_Status_ARRAYSIZE;
  
  typedef User_Available Available;
  static const Available UnknownA = User_Available_UnknownA;
  static const Available Open = User_Available_Open;
  static const Available Locked = User_Available_Locked;
  static const Available Delete = User_Available_Delete;
  static inline bool Available_IsValid(int value) {
    return User_Available_IsValid(value);
  }
  static const Available Available_MIN =
    User_Available_Available_MIN;
  static const Available Available_MAX =
    User_Available_Available_MAX;
  static const int Available_ARRAYSIZE =
    User_Available_Available_ARRAYSIZE;
  
  // accessors -------------------------------------------------------
  
  // optional string uuid = 1 [default = ""];
  inline bool has_uuid() const;
  inline void clear_uuid();
  static const int kUuidFieldNumber = 1;
  inline const ::std::string& uuid() const;
  inline void set_uuid(const ::std::string& value);
  inline void set_uuid(const char* value);
  inline void set_uuid(const char* value, size_t size);
  inline ::std::string* mutable_uuid();
  inline ::std::string* release_uuid();
  
  // optional string username = 2 [default = ""];
  inline bool has_username() const;
  inline void clear_username();
  static const int kUsernameFieldNumber = 2;
  inline const ::std::string& username() const;
  inline void set_username(const ::std::string& value);
  inline void set_username(const char* value);
  inline void set_username(const char* value, size_t size);
  inline ::std::string* mutable_username();
  inline ::std::string* release_username();
  
  // optional uint32 id = 3 [default = 0];
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 3;
  inline ::google::protobuf::uint32 id() const;
  inline void set_id(::google::protobuf::uint32 value);
  
  // optional uint32 softver = 4 [default = 0];
  inline bool has_softver() const;
  inline void clear_softver();
  static const int kSoftverFieldNumber = 4;
  inline ::google::protobuf::uint32 softver() const;
  inline void set_softver(::google::protobuf::uint32 value);
  
  // optional string nickname = 5 [default = ""];
  inline bool has_nickname() const;
  inline void clear_nickname();
  static const int kNicknameFieldNumber = 5;
  inline const ::std::string& nickname() const;
  inline void set_nickname(const ::std::string& value);
  inline void set_nickname(const char* value);
  inline void set_nickname(const char* value, size_t size);
  inline ::std::string* mutable_nickname();
  inline ::std::string* release_nickname();
  
  // optional uint32 level = 6 [default = 0];
  inline bool has_level() const;
  inline void clear_level();
  static const int kLevelFieldNumber = 6;
  inline ::google::protobuf::uint32 level() const;
  inline void set_level(::google::protobuf::uint32 value);
  
  // repeated uint32 songNumber = 7;
  inline int songnumber_size() const;
  inline void clear_songnumber();
  static const int kSongNumberFieldNumber = 7;
  inline ::google::protobuf::uint32 songnumber(int index) const;
  inline void set_songnumber(int index, ::google::protobuf::uint32 value);
  inline void add_songnumber(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      songnumber() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_songnumber();
  
  // repeated uint32 followingid = 8;
  inline int followingid_size() const;
  inline void clear_followingid();
  static const int kFollowingidFieldNumber = 8;
  inline ::google::protobuf::uint32 followingid(int index) const;
  inline void set_followingid(int index, ::google::protobuf::uint32 value);
  inline void add_followingid(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      followingid() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_followingid();
  
  // repeated uint32 followedid = 9;
  inline int followedid_size() const;
  inline void clear_followedid();
  static const int kFollowedidFieldNumber = 9;
  inline ::google::protobuf::uint32 followedid(int index) const;
  inline void set_followedid(int index, ::google::protobuf::uint32 value);
  inline void add_followedid(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      followedid() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_followedid();
  
  // repeated uint32 friendsid = 10;
  inline int friendsid_size() const;
  inline void clear_friendsid();
  static const int kFriendsidFieldNumber = 10;
  inline ::google::protobuf::uint32 friendsid(int index) const;
  inline void set_friendsid(int index, ::google::protobuf::uint32 value);
  inline void add_friendsid(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      friendsid() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_friendsid();
  
  // optional .multak.User.Status status = 11 [default = UnknownS];
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 11;
  inline ::multak::User_Status status() const;
  inline void set_status(::multak::User_Status value);
  
  // optional .multak.User.Available available = 12 [default = UnknownA];
  inline bool has_available() const;
  inline void clear_available();
  static const int kAvailableFieldNumber = 12;
  inline ::multak::User_Available available() const;
  inline void set_available(::multak::User_Available value);
  
  // optional string password = 13 [default = ""];
  inline bool has_password() const;
  inline void clear_password();
  static const int kPasswordFieldNumber = 13;
  inline const ::std::string& password() const;
  inline void set_password(const ::std::string& value);
  inline void set_password(const char* value);
  inline void set_password(const char* value, size_t size);
  inline ::std::string* mutable_password();
  inline ::std::string* release_password();
  
  // optional string region = 21 [default = ""];
  inline bool has_region() const;
  inline void clear_region();
  static const int kRegionFieldNumber = 21;
  inline const ::std::string& region() const;
  inline void set_region(const ::std::string& value);
  inline void set_region(const char* value);
  inline void set_region(const char* value, size_t size);
  inline ::std::string* mutable_region();
  inline ::std::string* release_region();
  
  // optional int32 age = 22 [default = 0];
  inline bool has_age() const;
  inline void clear_age();
  static const int kAgeFieldNumber = 22;
  inline ::google::protobuf::int32 age() const;
  inline void set_age(::google::protobuf::int32 value);
  
  // optional int32 sex = 23 [default = 0];
  inline bool has_sex() const;
  inline void clear_sex();
  static const int kSexFieldNumber = 23;
  inline ::google::protobuf::int32 sex() const;
  inline void set_sex(::google::protobuf::int32 value);
  
  // optional string address = 24 [default = ""];
  inline bool has_address() const;
  inline void clear_address();
  static const int kAddressFieldNumber = 24;
  inline const ::std::string& address() const;
  inline void set_address(const ::std::string& value);
  inline void set_address(const char* value);
  inline void set_address(const char* value, size_t size);
  inline ::std::string* mutable_address();
  inline ::std::string* release_address();
  
  // optional string homenumber = 25 [default = ""];
  inline bool has_homenumber() const;
  inline void clear_homenumber();
  static const int kHomenumberFieldNumber = 25;
  inline const ::std::string& homenumber() const;
  inline void set_homenumber(const ::std::string& value);
  inline void set_homenumber(const char* value);
  inline void set_homenumber(const char* value, size_t size);
  inline ::std::string* mutable_homenumber();
  inline ::std::string* release_homenumber();
  
  // optional string mobilenumber = 26 [default = ""];
  inline bool has_mobilenumber() const;
  inline void clear_mobilenumber();
  static const int kMobilenumberFieldNumber = 26;
  inline const ::std::string& mobilenumber() const;
  inline void set_mobilenumber(const ::std::string& value);
  inline void set_mobilenumber(const char* value);
  inline void set_mobilenumber(const char* value, size_t size);
  inline ::std::string* mutable_mobilenumber();
  inline ::std::string* release_mobilenumber();
  
  // optional bool allowMultipleLogins = 15;
  inline bool has_allowmultiplelogins() const;
  inline void clear_allowmultiplelogins();
  static const int kAllowMultipleLoginsFieldNumber = 15;
  inline bool allowmultiplelogins() const;
  inline void set_allowmultiplelogins(bool value);
  
  // optional string AssignInfo1 = 16;
  inline bool has_assigninfo1() const;
  inline void clear_assigninfo1();
  static const int kAssignInfo1FieldNumber = 16;
  inline const ::std::string& assigninfo1() const;
  inline void set_assigninfo1(const ::std::string& value);
  inline void set_assigninfo1(const char* value);
  inline void set_assigninfo1(const char* value, size_t size);
  inline ::std::string* mutable_assigninfo1();
  inline ::std::string* release_assigninfo1();
  
  // optional string AssignInfo2 = 17;
  inline bool has_assigninfo2() const;
  inline void clear_assigninfo2();
  static const int kAssignInfo2FieldNumber = 17;
  inline const ::std::string& assigninfo2() const;
  inline void set_assigninfo2(const ::std::string& value);
  inline void set_assigninfo2(const char* value);
  inline void set_assigninfo2(const char* value, size_t size);
  inline ::std::string* mutable_assigninfo2();
  inline ::std::string* release_assigninfo2();
  
  // optional int32 la = 18;
  inline bool has_la() const;
  inline void clear_la();
  static const int kLaFieldNumber = 18;
  inline ::google::protobuf::int32 la() const;
  inline void set_la(::google::protobuf::int32 value);
  
  // optional int32 lo = 19;
  inline bool has_lo() const;
  inline void clear_lo();
  static const int kLoFieldNumber = 19;
  inline ::google::protobuf::int32 lo() const;
  inline void set_lo(::google::protobuf::int32 value);
  
  // optional int32 musicbox = 20;
  inline bool has_musicbox() const;
  inline void clear_musicbox();
  static const int kMusicboxFieldNumber = 20;
  inline ::google::protobuf::int32 musicbox() const;
  inline void set_musicbox(::google::protobuf::int32 value);
  
  // repeated uint32 propid = 14;
  inline int propid_size() const;
  inline void clear_propid();
  static const int kPropidFieldNumber = 14;
  inline ::google::protobuf::uint32 propid(int index) const;
  inline void set_propid(int index, ::google::protobuf::uint32 value);
  inline void add_propid(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      propid() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_propid();
  
  // @@protoc_insertion_point(class_scope:multak.User)
 private:
  inline void set_has_uuid();
  inline void clear_has_uuid();
  inline void set_has_username();
  inline void clear_has_username();
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_softver();
  inline void clear_has_softver();
  inline void set_has_nickname();
  inline void clear_has_nickname();
  inline void set_has_level();
  inline void clear_has_level();
  inline void set_has_status();
  inline void clear_has_status();
  inline void set_has_available();
  inline void clear_has_available();
  inline void set_has_password();
  inline void clear_has_password();
  inline void set_has_region();
  inline void clear_has_region();
  inline void set_has_age();
  inline void clear_has_age();
  inline void set_has_sex();
  inline void clear_has_sex();
  inline void set_has_address();
  inline void clear_has_address();
  inline void set_has_homenumber();
  inline void clear_has_homenumber();
  inline void set_has_mobilenumber();
  inline void clear_has_mobilenumber();
  inline void set_has_allowmultiplelogins();
  inline void clear_has_allowmultiplelogins();
  inline void set_has_assigninfo1();
  inline void clear_has_assigninfo1();
  inline void set_has_assigninfo2();
  inline void clear_has_assigninfo2();
  inline void set_has_la();
  inline void clear_has_la();
  inline void set_has_lo();
  inline void clear_has_lo();
  inline void set_has_musicbox();
  inline void clear_has_musicbox();
  
  ::std::string* uuid_;
  ::std::string* username_;
  ::google::protobuf::uint32 id_;
  ::google::protobuf::uint32 softver_;
  ::std::string* nickname_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > songnumber_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > followingid_;
  ::google::protobuf::uint32 level_;
  int status_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > followedid_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > friendsid_;
  ::std::string* password_;
  int available_;
  ::google::protobuf::int32 age_;
  ::std::string* region_;
  ::std::string* address_;
  ::std::string* homenumber_;
  ::google::protobuf::int32 sex_;
  bool allowmultiplelogins_;
  ::std::string* mobilenumber_;
  ::std::string* assigninfo1_;
  ::std::string* assigninfo2_;
  ::google::protobuf::int32 la_;
  ::google::protobuf::int32 lo_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > propid_;
  ::google::protobuf::int32 musicbox_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(26 + 31) / 32];
  
  friend void  protobuf_AddDesc_multak_2eUser_2eproto();
  friend void protobuf_AssignDesc_multak_2eUser_2eproto();
  friend void protobuf_ShutdownFile_multak_2eUser_2eproto();
  
  void InitAsDefaultInstance();
  static User* default_instance_;
};
// ===================================================================


// ===================================================================

// User

// optional string uuid = 1 [default = ""];
inline bool User::has_uuid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void User::set_has_uuid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void User::clear_has_uuid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void User::clear_uuid() {
  if (uuid_ != &::google::protobuf::internal::kEmptyString) {
    uuid_->clear();
  }
  clear_has_uuid();
}
inline const ::std::string& User::uuid() const {
  return *uuid_;
}
inline void User::set_uuid(const ::std::string& value) {
  set_has_uuid();
  if (uuid_ == &::google::protobuf::internal::kEmptyString) {
    uuid_ = new ::std::string;
  }
  uuid_->assign(value);
}
inline void User::set_uuid(const char* value) {
  set_has_uuid();
  if (uuid_ == &::google::protobuf::internal::kEmptyString) {
    uuid_ = new ::std::string;
  }
  uuid_->assign(value);
}
inline void User::set_uuid(const char* value, size_t size) {
  set_has_uuid();
  if (uuid_ == &::google::protobuf::internal::kEmptyString) {
    uuid_ = new ::std::string;
  }
  uuid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* User::mutable_uuid() {
  set_has_uuid();
  if (uuid_ == &::google::protobuf::internal::kEmptyString) {
    uuid_ = new ::std::string;
  }
  return uuid_;
}
inline ::std::string* User::release_uuid() {
  clear_has_uuid();
  if (uuid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = uuid_;
    uuid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string username = 2 [default = ""];
inline bool User::has_username() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void User::set_has_username() {
  _has_bits_[0] |= 0x00000002u;
}
inline void User::clear_has_username() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void User::clear_username() {
  if (username_ != &::google::protobuf::internal::kEmptyString) {
    username_->clear();
  }
  clear_has_username();
}
inline const ::std::string& User::username() const {
  return *username_;
}
inline void User::set_username(const ::std::string& value) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(value);
}
inline void User::set_username(const char* value) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(value);
}
inline void User::set_username(const char* value, size_t size) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* User::mutable_username() {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  return username_;
}
inline ::std::string* User::release_username() {
  clear_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = username_;
    username_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional uint32 id = 3 [default = 0];
inline bool User::has_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void User::set_has_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void User::clear_has_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void User::clear_id() {
  id_ = 0u;
  clear_has_id();
}
inline ::google::protobuf::uint32 User::id() const {
  return id_;
}
inline void User::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
}

// optional uint32 softver = 4 [default = 0];
inline bool User::has_softver() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void User::set_has_softver() {
  _has_bits_[0] |= 0x00000008u;
}
inline void User::clear_has_softver() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void User::clear_softver() {
  softver_ = 0u;
  clear_has_softver();
}
inline ::google::protobuf::uint32 User::softver() const {
  return softver_;
}
inline void User::set_softver(::google::protobuf::uint32 value) {
  set_has_softver();
  softver_ = value;
}

// optional string nickname = 5 [default = ""];
inline bool User::has_nickname() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void User::set_has_nickname() {
  _has_bits_[0] |= 0x00000010u;
}
inline void User::clear_has_nickname() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void User::clear_nickname() {
  if (nickname_ != &::google::protobuf::internal::kEmptyString) {
    nickname_->clear();
  }
  clear_has_nickname();
}
inline const ::std::string& User::nickname() const {
  return *nickname_;
}
inline void User::set_nickname(const ::std::string& value) {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::kEmptyString) {
    nickname_ = new ::std::string;
  }
  nickname_->assign(value);
}
inline void User::set_nickname(const char* value) {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::kEmptyString) {
    nickname_ = new ::std::string;
  }
  nickname_->assign(value);
}
inline void User::set_nickname(const char* value, size_t size) {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::kEmptyString) {
    nickname_ = new ::std::string;
  }
  nickname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* User::mutable_nickname() {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::kEmptyString) {
    nickname_ = new ::std::string;
  }
  return nickname_;
}
inline ::std::string* User::release_nickname() {
  clear_has_nickname();
  if (nickname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = nickname_;
    nickname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional uint32 level = 6 [default = 0];
inline bool User::has_level() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void User::set_has_level() {
  _has_bits_[0] |= 0x00000020u;
}
inline void User::clear_has_level() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void User::clear_level() {
  level_ = 0u;
  clear_has_level();
}
inline ::google::protobuf::uint32 User::level() const {
  return level_;
}
inline void User::set_level(::google::protobuf::uint32 value) {
  set_has_level();
  level_ = value;
}

// repeated uint32 songNumber = 7;
inline int User::songnumber_size() const {
  return songnumber_.size();
}
inline void User::clear_songnumber() {
  songnumber_.Clear();
}
inline ::google::protobuf::uint32 User::songnumber(int index) const {
  return songnumber_.Get(index);
}
inline void User::set_songnumber(int index, ::google::protobuf::uint32 value) {
  songnumber_.Set(index, value);
}
inline void User::add_songnumber(::google::protobuf::uint32 value) {
  songnumber_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
User::songnumber() const {
  return songnumber_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
User::mutable_songnumber() {
  return &songnumber_;
}

// repeated uint32 followingid = 8;
inline int User::followingid_size() const {
  return followingid_.size();
}
inline void User::clear_followingid() {
  followingid_.Clear();
}
inline ::google::protobuf::uint32 User::followingid(int index) const {
  return followingid_.Get(index);
}
inline void User::set_followingid(int index, ::google::protobuf::uint32 value) {
  followingid_.Set(index, value);
}
inline void User::add_followingid(::google::protobuf::uint32 value) {
  followingid_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
User::followingid() const {
  return followingid_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
User::mutable_followingid() {
  return &followingid_;
}

// repeated uint32 followedid = 9;
inline int User::followedid_size() const {
  return followedid_.size();
}
inline void User::clear_followedid() {
  followedid_.Clear();
}
inline ::google::protobuf::uint32 User::followedid(int index) const {
  return followedid_.Get(index);
}
inline void User::set_followedid(int index, ::google::protobuf::uint32 value) {
  followedid_.Set(index, value);
}
inline void User::add_followedid(::google::protobuf::uint32 value) {
  followedid_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
User::followedid() const {
  return followedid_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
User::mutable_followedid() {
  return &followedid_;
}

// repeated uint32 friendsid = 10;
inline int User::friendsid_size() const {
  return friendsid_.size();
}
inline void User::clear_friendsid() {
  friendsid_.Clear();
}
inline ::google::protobuf::uint32 User::friendsid(int index) const {
  return friendsid_.Get(index);
}
inline void User::set_friendsid(int index, ::google::protobuf::uint32 value) {
  friendsid_.Set(index, value);
}
inline void User::add_friendsid(::google::protobuf::uint32 value) {
  friendsid_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
User::friendsid() const {
  return friendsid_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
User::mutable_friendsid() {
  return &friendsid_;
}

// optional .multak.User.Status status = 11 [default = UnknownS];
inline bool User::has_status() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void User::set_has_status() {
  _has_bits_[0] |= 0x00000400u;
}
inline void User::clear_has_status() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void User::clear_status() {
  status_ = 0;
  clear_has_status();
}
inline ::multak::User_Status User::status() const {
  return static_cast< ::multak::User_Status >(status_);
}
inline void User::set_status(::multak::User_Status value) {
  GOOGLE_DCHECK(::multak::User_Status_IsValid(value));
  set_has_status();
  status_ = value;
}

// optional .multak.User.Available available = 12 [default = UnknownA];
inline bool User::has_available() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void User::set_has_available() {
  _has_bits_[0] |= 0x00000800u;
}
inline void User::clear_has_available() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void User::clear_available() {
  available_ = 0;
  clear_has_available();
}
inline ::multak::User_Available User::available() const {
  return static_cast< ::multak::User_Available >(available_);
}
inline void User::set_available(::multak::User_Available value) {
  GOOGLE_DCHECK(::multak::User_Available_IsValid(value));
  set_has_available();
  available_ = value;
}

// optional string password = 13 [default = ""];
inline bool User::has_password() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void User::set_has_password() {
  _has_bits_[0] |= 0x00001000u;
}
inline void User::clear_has_password() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void User::clear_password() {
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    password_->clear();
  }
  clear_has_password();
}
inline const ::std::string& User::password() const {
  return *password_;
}
inline void User::set_password(const ::std::string& value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void User::set_password(const char* value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void User::set_password(const char* value, size_t size) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* User::mutable_password() {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  return password_;
}
inline ::std::string* User::release_password() {
  clear_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = password_;
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string region = 21 [default = ""];
inline bool User::has_region() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void User::set_has_region() {
  _has_bits_[0] |= 0x00002000u;
}
inline void User::clear_has_region() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void User::clear_region() {
  if (region_ != &::google::protobuf::internal::kEmptyString) {
    region_->clear();
  }
  clear_has_region();
}
inline const ::std::string& User::region() const {
  return *region_;
}
inline void User::set_region(const ::std::string& value) {
  set_has_region();
  if (region_ == &::google::protobuf::internal::kEmptyString) {
    region_ = new ::std::string;
  }
  region_->assign(value);
}
inline void User::set_region(const char* value) {
  set_has_region();
  if (region_ == &::google::protobuf::internal::kEmptyString) {
    region_ = new ::std::string;
  }
  region_->assign(value);
}
inline void User::set_region(const char* value, size_t size) {
  set_has_region();
  if (region_ == &::google::protobuf::internal::kEmptyString) {
    region_ = new ::std::string;
  }
  region_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* User::mutable_region() {
  set_has_region();
  if (region_ == &::google::protobuf::internal::kEmptyString) {
    region_ = new ::std::string;
  }
  return region_;
}
inline ::std::string* User::release_region() {
  clear_has_region();
  if (region_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = region_;
    region_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 age = 22 [default = 0];
inline bool User::has_age() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void User::set_has_age() {
  _has_bits_[0] |= 0x00004000u;
}
inline void User::clear_has_age() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void User::clear_age() {
  age_ = 0;
  clear_has_age();
}
inline ::google::protobuf::int32 User::age() const {
  return age_;
}
inline void User::set_age(::google::protobuf::int32 value) {
  set_has_age();
  age_ = value;
}

// optional int32 sex = 23 [default = 0];
inline bool User::has_sex() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void User::set_has_sex() {
  _has_bits_[0] |= 0x00008000u;
}
inline void User::clear_has_sex() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void User::clear_sex() {
  sex_ = 0;
  clear_has_sex();
}
inline ::google::protobuf::int32 User::sex() const {
  return sex_;
}
inline void User::set_sex(::google::protobuf::int32 value) {
  set_has_sex();
  sex_ = value;
}

// optional string address = 24 [default = ""];
inline bool User::has_address() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void User::set_has_address() {
  _has_bits_[0] |= 0x00010000u;
}
inline void User::clear_has_address() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void User::clear_address() {
  if (address_ != &::google::protobuf::internal::kEmptyString) {
    address_->clear();
  }
  clear_has_address();
}
inline const ::std::string& User::address() const {
  return *address_;
}
inline void User::set_address(const ::std::string& value) {
  set_has_address();
  if (address_ == &::google::protobuf::internal::kEmptyString) {
    address_ = new ::std::string;
  }
  address_->assign(value);
}
inline void User::set_address(const char* value) {
  set_has_address();
  if (address_ == &::google::protobuf::internal::kEmptyString) {
    address_ = new ::std::string;
  }
  address_->assign(value);
}
inline void User::set_address(const char* value, size_t size) {
  set_has_address();
  if (address_ == &::google::protobuf::internal::kEmptyString) {
    address_ = new ::std::string;
  }
  address_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* User::mutable_address() {
  set_has_address();
  if (address_ == &::google::protobuf::internal::kEmptyString) {
    address_ = new ::std::string;
  }
  return address_;
}
inline ::std::string* User::release_address() {
  clear_has_address();
  if (address_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = address_;
    address_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string homenumber = 25 [default = ""];
inline bool User::has_homenumber() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void User::set_has_homenumber() {
  _has_bits_[0] |= 0x00020000u;
}
inline void User::clear_has_homenumber() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void User::clear_homenumber() {
  if (homenumber_ != &::google::protobuf::internal::kEmptyString) {
    homenumber_->clear();
  }
  clear_has_homenumber();
}
inline const ::std::string& User::homenumber() const {
  return *homenumber_;
}
inline void User::set_homenumber(const ::std::string& value) {
  set_has_homenumber();
  if (homenumber_ == &::google::protobuf::internal::kEmptyString) {
    homenumber_ = new ::std::string;
  }
  homenumber_->assign(value);
}
inline void User::set_homenumber(const char* value) {
  set_has_homenumber();
  if (homenumber_ == &::google::protobuf::internal::kEmptyString) {
    homenumber_ = new ::std::string;
  }
  homenumber_->assign(value);
}
inline void User::set_homenumber(const char* value, size_t size) {
  set_has_homenumber();
  if (homenumber_ == &::google::protobuf::internal::kEmptyString) {
    homenumber_ = new ::std::string;
  }
  homenumber_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* User::mutable_homenumber() {
  set_has_homenumber();
  if (homenumber_ == &::google::protobuf::internal::kEmptyString) {
    homenumber_ = new ::std::string;
  }
  return homenumber_;
}
inline ::std::string* User::release_homenumber() {
  clear_has_homenumber();
  if (homenumber_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = homenumber_;
    homenumber_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string mobilenumber = 26 [default = ""];
inline bool User::has_mobilenumber() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void User::set_has_mobilenumber() {
  _has_bits_[0] |= 0x00040000u;
}
inline void User::clear_has_mobilenumber() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void User::clear_mobilenumber() {
  if (mobilenumber_ != &::google::protobuf::internal::kEmptyString) {
    mobilenumber_->clear();
  }
  clear_has_mobilenumber();
}
inline const ::std::string& User::mobilenumber() const {
  return *mobilenumber_;
}
inline void User::set_mobilenumber(const ::std::string& value) {
  set_has_mobilenumber();
  if (mobilenumber_ == &::google::protobuf::internal::kEmptyString) {
    mobilenumber_ = new ::std::string;
  }
  mobilenumber_->assign(value);
}
inline void User::set_mobilenumber(const char* value) {
  set_has_mobilenumber();
  if (mobilenumber_ == &::google::protobuf::internal::kEmptyString) {
    mobilenumber_ = new ::std::string;
  }
  mobilenumber_->assign(value);
}
inline void User::set_mobilenumber(const char* value, size_t size) {
  set_has_mobilenumber();
  if (mobilenumber_ == &::google::protobuf::internal::kEmptyString) {
    mobilenumber_ = new ::std::string;
  }
  mobilenumber_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* User::mutable_mobilenumber() {
  set_has_mobilenumber();
  if (mobilenumber_ == &::google::protobuf::internal::kEmptyString) {
    mobilenumber_ = new ::std::string;
  }
  return mobilenumber_;
}
inline ::std::string* User::release_mobilenumber() {
  clear_has_mobilenumber();
  if (mobilenumber_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = mobilenumber_;
    mobilenumber_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional bool allowMultipleLogins = 15;
inline bool User::has_allowmultiplelogins() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void User::set_has_allowmultiplelogins() {
  _has_bits_[0] |= 0x00080000u;
}
inline void User::clear_has_allowmultiplelogins() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void User::clear_allowmultiplelogins() {
  allowmultiplelogins_ = false;
  clear_has_allowmultiplelogins();
}
inline bool User::allowmultiplelogins() const {
  return allowmultiplelogins_;
}
inline void User::set_allowmultiplelogins(bool value) {
  set_has_allowmultiplelogins();
  allowmultiplelogins_ = value;
}

// optional string AssignInfo1 = 16;
inline bool User::has_assigninfo1() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void User::set_has_assigninfo1() {
  _has_bits_[0] |= 0x00100000u;
}
inline void User::clear_has_assigninfo1() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void User::clear_assigninfo1() {
  if (assigninfo1_ != &::google::protobuf::internal::kEmptyString) {
    assigninfo1_->clear();
  }
  clear_has_assigninfo1();
}
inline const ::std::string& User::assigninfo1() const {
  return *assigninfo1_;
}
inline void User::set_assigninfo1(const ::std::string& value) {
  set_has_assigninfo1();
  if (assigninfo1_ == &::google::protobuf::internal::kEmptyString) {
    assigninfo1_ = new ::std::string;
  }
  assigninfo1_->assign(value);
}
inline void User::set_assigninfo1(const char* value) {
  set_has_assigninfo1();
  if (assigninfo1_ == &::google::protobuf::internal::kEmptyString) {
    assigninfo1_ = new ::std::string;
  }
  assigninfo1_->assign(value);
}
inline void User::set_assigninfo1(const char* value, size_t size) {
  set_has_assigninfo1();
  if (assigninfo1_ == &::google::protobuf::internal::kEmptyString) {
    assigninfo1_ = new ::std::string;
  }
  assigninfo1_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* User::mutable_assigninfo1() {
  set_has_assigninfo1();
  if (assigninfo1_ == &::google::protobuf::internal::kEmptyString) {
    assigninfo1_ = new ::std::string;
  }
  return assigninfo1_;
}
inline ::std::string* User::release_assigninfo1() {
  clear_has_assigninfo1();
  if (assigninfo1_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = assigninfo1_;
    assigninfo1_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string AssignInfo2 = 17;
inline bool User::has_assigninfo2() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void User::set_has_assigninfo2() {
  _has_bits_[0] |= 0x00200000u;
}
inline void User::clear_has_assigninfo2() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void User::clear_assigninfo2() {
  if (assigninfo2_ != &::google::protobuf::internal::kEmptyString) {
    assigninfo2_->clear();
  }
  clear_has_assigninfo2();
}
inline const ::std::string& User::assigninfo2() const {
  return *assigninfo2_;
}
inline void User::set_assigninfo2(const ::std::string& value) {
  set_has_assigninfo2();
  if (assigninfo2_ == &::google::protobuf::internal::kEmptyString) {
    assigninfo2_ = new ::std::string;
  }
  assigninfo2_->assign(value);
}
inline void User::set_assigninfo2(const char* value) {
  set_has_assigninfo2();
  if (assigninfo2_ == &::google::protobuf::internal::kEmptyString) {
    assigninfo2_ = new ::std::string;
  }
  assigninfo2_->assign(value);
}
inline void User::set_assigninfo2(const char* value, size_t size) {
  set_has_assigninfo2();
  if (assigninfo2_ == &::google::protobuf::internal::kEmptyString) {
    assigninfo2_ = new ::std::string;
  }
  assigninfo2_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* User::mutable_assigninfo2() {
  set_has_assigninfo2();
  if (assigninfo2_ == &::google::protobuf::internal::kEmptyString) {
    assigninfo2_ = new ::std::string;
  }
  return assigninfo2_;
}
inline ::std::string* User::release_assigninfo2() {
  clear_has_assigninfo2();
  if (assigninfo2_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = assigninfo2_;
    assigninfo2_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 la = 18;
inline bool User::has_la() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void User::set_has_la() {
  _has_bits_[0] |= 0x00400000u;
}
inline void User::clear_has_la() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void User::clear_la() {
  la_ = 0;
  clear_has_la();
}
inline ::google::protobuf::int32 User::la() const {
  return la_;
}
inline void User::set_la(::google::protobuf::int32 value) {
  set_has_la();
  la_ = value;
}

// optional int32 lo = 19;
inline bool User::has_lo() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void User::set_has_lo() {
  _has_bits_[0] |= 0x00800000u;
}
inline void User::clear_has_lo() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void User::clear_lo() {
  lo_ = 0;
  clear_has_lo();
}
inline ::google::protobuf::int32 User::lo() const {
  return lo_;
}
inline void User::set_lo(::google::protobuf::int32 value) {
  set_has_lo();
  lo_ = value;
}

// optional int32 musicbox = 20;
inline bool User::has_musicbox() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void User::set_has_musicbox() {
  _has_bits_[0] |= 0x01000000u;
}
inline void User::clear_has_musicbox() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void User::clear_musicbox() {
  musicbox_ = 0;
  clear_has_musicbox();
}
inline ::google::protobuf::int32 User::musicbox() const {
  return musicbox_;
}
inline void User::set_musicbox(::google::protobuf::int32 value) {
  set_has_musicbox();
  musicbox_ = value;
}

// repeated uint32 propid = 14;
inline int User::propid_size() const {
  return propid_.size();
}
inline void User::clear_propid() {
  propid_.Clear();
}
inline ::google::protobuf::uint32 User::propid(int index) const {
  return propid_.Get(index);
}
inline void User::set_propid(int index, ::google::protobuf::uint32 value) {
  propid_.Set(index, value);
}
inline void User::add_propid(::google::protobuf::uint32 value) {
  propid_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
User::propid() const {
  return propid_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
User::mutable_propid() {
  return &propid_;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace multak

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_multak_2eUser_2eproto__INCLUDED
